<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Breakout - Professional Edition</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #000000;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            position: relative;
            overflow: hidden;
        }

        /* Animated background */
        .background-gradient {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #000000 0%, #0a0015 50%, #000000 100%);
            z-index: 0;
        }

        .stars {
            position: fixed;
            width: 100%;
            height: 100%;
            background-image: 
                radial-gradient(2px 2px at 20px 30px, white, transparent),
                radial-gradient(2px 2px at 60px 70px, white, transparent),
                radial-gradient(1px 1px at 50px 50px, white, transparent),
                radial-gradient(1px 1px at 130px 80px, white, transparent),
                radial-gradient(2px 2px at 90px 150px, white, transparent);
            background-repeat: repeat;
            background-size: 200px 200px;
            opacity: 0.4;
            animation: starsMove 100s linear infinite;
            z-index: 1;
        }

        @keyframes starsMove {
            from { transform: translateY(0); }
            to { transform: translateY(-200px); }
        }

        /* Purple glow orbs */
        .orb {
            position: fixed;
            border-radius: 50%;
            filter: blur(60px);
            opacity: 0.1;
            z-index: 2;
            animation: float 20s ease-in-out infinite;
        }

        .orb-1 {
            width: 400px;
            height: 400px;
            background: radial-gradient(circle, #6b21a8, transparent);
            top: -100px;
            left: -100px;
            animation-duration: 25s;
        }

        .orb-2 {
            width: 350px;
            height: 350px;
            background: radial-gradient(circle, #4a0080, transparent);
            bottom: -100px;
            right: -100px;
            animation-duration: 30s;
            animation-delay: -10s;
        }

        @keyframes float {
            0%, 100% { transform: translate(0, 0) scale(1); }
            33% { transform: translate(50px, -50px) scale(1.1); }
            66% { transform: translate(-50px, 50px) scale(0.9); }
        }

        .game-container {
            background: rgba(255, 255, 255, 0.03);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 
                0 20px 50px rgba(0, 0, 0, 0.5),
                0 0 100px rgba(139, 92, 246, 0.1),
                inset 0 1px 0 rgba(255, 255, 255, 0.05);
            text-align: center;
            position: relative;
            z-index: 10;
        }

        h1 {
            margin-bottom: 20px;
            font-size: 3em;
            text-shadow: 3px 3px 6px rgba(0, 0, 0, 0.3);
            background: linear-gradient(135deg, #ffd93d, #ff6b6b);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .game-info {
            display: flex;
            justify-content: space-around;
            margin-bottom: 20px;
            font-size: 1.2em;
        }

        .info-box {
            background: rgba(255, 255, 255, 0.2);
            padding: 10px 20px;
            border-radius: 10px;
            min-width: 120px;
        }

        .lives {
            color: #ff6b6b;
            font-size: 1.5em;
        }

        canvas {
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            background: linear-gradient(180deg, #0a0e27 0%, #1a237e 100%);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            cursor: none;
        }

        .controls {
            margin-top: 20px;
            display: flex;
            gap: 10px;
            justify-content: center;
        }

        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 30px;
            font-size: 1.1em;
            border-radius: 10px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.3);
        }

        .game-over-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            padding: 40px;
            border-radius: 15px;
            display: none;
            z-index: 100;
            text-align: center;
        }

        .game-over-modal.show {
            display: block;
        }

        .game-over-modal h2 {
            color: #ff6b6b;
            margin-bottom: 20px;
            font-size: 2.5em;
        }

        .instructions {
            margin-top: 20px;
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 10px;
        }

        .instructions h3 {
            margin-bottom: 10px;
            color: #ffd93d;
        }

        .high-score {
            color: #ffd93d;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="background-gradient"></div>
    <div class="stars"></div>
    <div class="orb orb-1"></div>
    <div class="orb orb-2"></div>
    
    <div class="game-container">
        <h1>üß± BREAKOUT</h1>
        
        <div class="game-info">
            <div class="info-box">
                <div>Score</div>
                <div id="score">0</div>
            </div>
            <div class="info-box">
                <div>Level</div>
                <div id="level">1</div>
            </div>
            <div class="info-box">
                <div>Lives</div>
                <div class="lives" id="lives">‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è</div>
            </div>
            <div class="info-box">
                <div>High Score</div>
                <div class="high-score" id="highScore">0</div>
            </div>
        </div>

        <canvas id="gameCanvas" width="800" height="600"></canvas>

        <div class="controls">
            <button onclick="startGame()">Start Game</button>
            <button onclick="togglePause()">Pause</button>
            <button onclick="resetGame()">Reset</button>
        </div>

        <div class="instructions">
            <h3>How to Play:</h3>
            <p>Move your mouse or use Arrow Keys to control the paddle</p>
            <p>Click or press Space to launch the ball</p>
            <p>Break all bricks to advance to the next level!</p>
            <p>Catch power-ups for special abilities!</p>
        </div>
    </div>

    <div class="game-over-modal" id="gameOverModal">
        <h2 id="gameOverTitle">Game Over!</h2>
        <p>Final Score: <span id="finalScore">0</span></p>
        <p>Level Reached: <span id="finalLevel">1</span></p>
        <button onclick="resetGame()">Play Again</button>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Game variables
        let gameRunning = false;
        let gamePaused = false;
        let animationId;
        let score = 0;
        let lives = 3;
        let level = 1;
        let highScore = localStorage.getItem('breakoutHighScore') || 0;

        // Paddle
        const paddle = {
            width: 100,
            height: 15,
            x: canvas.width / 2 - 50,
            y: canvas.height - 30,
            speed: 8,
            dx: 0
        };

        // Ball
        let ballX = canvas.width / 2;
        let ballY = canvas.height - 50;
        let ballDX = 4;
        let ballDY = -4;
        const ballRadius = 8;

        // Bricks
        const brickRowCount = 5;
        const brickColumnCount = 9;
        const brickWidth = 75;
        const brickHeight = 20;
        const brickPadding = 10;
        const brickOffsetTop = 60;
        const brickOffsetLeft = 30;
        let bricks = [];

        // Initialize bricks
        function initBricks() {
            bricks = [];
            for (let c = 0; c < brickColumnCount; c++) {
                bricks[c] = [];
                for (let r = 0; r < brickRowCount; r++) {
                    bricks[c][r] = { x: 0, y: 0, status: 1, color: getRowColor(r) };
                }
            }
        }

        function getRowColor(row) {
            const colors = ['#ff6b6b', '#4ecdc4', '#ffd93d', '#95e1d3', '#f38181'];
            return colors[row % colors.length];
        }

        // Drawing functions
        function drawBall() {
            ctx.beginPath();
            ctx.arc(ballX, ballY, ballRadius, 0, Math.PI * 2);
            ctx.fillStyle = '#ffffff';
            ctx.fill();
            ctx.strokeStyle = '#4ecdc4';
            ctx.lineWidth = 2;
            ctx.stroke();
            ctx.closePath();
        }

        function drawPaddle() {
            ctx.fillStyle = '#4ecdc4';
            ctx.fillRect(paddle.x, paddle.y, paddle.width, paddle.height);
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 2;
            ctx.strokeRect(paddle.x, paddle.y, paddle.width, paddle.height);
        }

        function drawBricks() {
            for (let c = 0; c < brickColumnCount; c++) {
                for (let r = 0; r < brickRowCount; r++) {
                    if (bricks[c][r].status === 1) {
                        const brickX = c * (brickWidth + brickPadding) + brickOffsetLeft;
                        const brickY = r * (brickHeight + brickPadding) + brickOffsetTop;
                        bricks[c][r].x = brickX;
                        bricks[c][r].y = brickY;
                        
                        ctx.fillStyle = bricks[c][r].color;
                        ctx.fillRect(brickX, brickY, brickWidth, brickHeight);
                        
                        ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                        ctx.lineWidth = 1;
                        ctx.strokeRect(brickX, brickY, brickWidth, brickHeight);
                    }
                }
            }
        }

        // Collision detection
        function collisionDetection() {
            for (let c = 0; c < brickColumnCount; c++) {
                for (let r = 0; r < brickRowCount; r++) {
                    const b = bricks[c][r];
                    if (b.status === 1) {
                        if (ballX > b.x && ballX < b.x + brickWidth && 
                            ballY > b.y && ballY < b.y + brickHeight) {
                            ballDY = -ballDY;
                            b.status = 0;
                            score += (5 - r) * 10; // Higher rows worth more points
                            updateScore();
                            
                            // Check if level complete
                            if (checkWin()) {
                                levelComplete();
                            }
                        }
                    }
                }
            }
        }

        function checkWin() {
            for (let c = 0; c < brickColumnCount; c++) {
                for (let r = 0; r < brickRowCount; r++) {
                    if (bricks[c][r].status === 1) {
                        return false;
                    }
                }
            }
            return true;
        }

        function updateScore() {
            document.getElementById('score').textContent = score;
            if (score > highScore) {
                highScore = score;
                localStorage.setItem('breakoutHighScore', highScore);
                document.getElementById('highScore').textContent = highScore;
            }
        }

        function updateLives() {
            const hearts = '‚ù§Ô∏è'.repeat(Math.max(0, lives));
            document.getElementById('lives').textContent = hearts || 'üíî';
        }

        // Game loop
        function gameLoop() {
            if (!gameRunning || gamePaused) return;

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            drawBricks();
            drawBall();
            drawPaddle();
            collisionDetection();

            // Ball movement
            ballX += ballDX;
            ballY += ballDY;

            // Ball collision with walls
            if (ballX + ballDX > canvas.width - ballRadius || ballX + ballDX < ballRadius) {
                ballDX = -ballDX;
            }
            if (ballY + ballDY < ballRadius) {
                ballDY = -ballDY;
            } else if (ballY + ballDY > canvas.height - ballRadius) {
                // Ball hit bottom - lose life
                if (ballX > paddle.x && ballX < paddle.x + paddle.width && 
                    ballY > paddle.y - ballRadius && ballY < paddle.y + paddle.height) {
                    // Hit paddle
                    ballDY = -ballDY;
                    // Add angle based on where ball hits paddle
                    const hitPos = (ballX - paddle.x) / paddle.width;
                    ballDX = 8 * (hitPos - 0.5);
                } else {
                    // Missed paddle
                    lives--;
                    updateLives();
                    if (lives <= 0) {
                        gameOver();
                    } else {
                        resetBall();
                    }
                }
            }

            // Paddle movement
            paddle.x += paddle.dx;
            if (paddle.x < 0) paddle.x = 0;
            if (paddle.x + paddle.width > canvas.width) paddle.x = canvas.width - paddle.width;

            animationId = requestAnimationFrame(gameLoop);
        }

        function resetBall() {
            ballX = canvas.width / 2;
            ballY = canvas.height - 50;
            ballDX = 4 * (Math.random() > 0.5 ? 1 : -1);
            ballDY = -4;
        }

        function levelComplete() {
            level++;
            document.getElementById('level').textContent = level;
            ballDX *= 1.1; // Increase speed
            ballDY *= 1.1;
            initBricks();
            resetBall();
        }

        function gameOver() {
            gameRunning = false;
            document.getElementById('finalScore').textContent = score;
            document.getElementById('finalLevel').textContent = level;
            document.getElementById('gameOverTitle').textContent = checkWin() ? 'You Win!' : 'Game Over!';
            document.getElementById('gameOverModal').classList.add('show');
        }

        function startGame() {
            if (gameRunning) return;
            
            gameRunning = true;
            gamePaused = false;
            score = 0;
            lives = 3;
            level = 1;
            
            initBricks();
            resetBall();
            updateScore();
            updateLives();
            document.getElementById('level').textContent = level;
            document.getElementById('highScore').textContent = highScore;
            
            gameLoop();
        }

        function togglePause() {
            if (!gameRunning) return;
            gamePaused = !gamePaused;
            if (!gamePaused) gameLoop();
        }

        function resetGame() {
            gameRunning = false;
            cancelAnimationFrame(animationId);
            document.getElementById('gameOverModal').classList.remove('show');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            startGame();
        }

        // Mouse control
        canvas.addEventListener('mousemove', (e) => {
            if (!gameRunning) return;
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            paddle.x = mouseX - paddle.width / 2;
            
            // Keep paddle in bounds
            if (paddle.x < 0) paddle.x = 0;
            if (paddle.x + paddle.width > canvas.width) paddle.x = canvas.width - paddle.width;
        });

        // Keyboard controls
        document.addEventListener('keydown', (e) => {
            if (!gameRunning) return;
            
            if (e.key === 'ArrowLeft') {
                paddle.dx = -paddle.speed;
            } else if (e.key === 'ArrowRight') {
                paddle.dx = paddle.speed;
            } else if (e.key === ' ') {
                e.preventDefault();
                if (ballDX === 0) {
                    ballDX = 4 * (Math.random() > 0.5 ? 1 : -1);
                }
            }
        });

        document.addEventListener('keyup', (e) => {
            if (e.key === 'ArrowLeft' || e.key === 'ArrowRight') {
                paddle.dx = 0;
            }
        });

        // Click to launch
        canvas.addEventListener('click', () => {
            if (!gameRunning) return;
            if (ballDX === 0) {
                ballDX = 4 * (Math.random() > 0.5 ? 1 : -1);
            }
        });

        // Initialize high score display
        document.getElementById('highScore').textContent = highScore;
    </script>
</body>
</html>
