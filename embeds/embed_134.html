<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebCut Pro</title>
    <style>
        :root {
            --bg-dark: #121212;
            --bg-panel: #1d1d1f;
            --bg-light: #2a2a2b;
            --accent: #00ebc7;
            --accent-hover: #00c2a4;
            --text-main: #ffffff;
            --text-dim: #a0a0a0;
            --border: #383838;
            --timeline-bg: #181818;
            --block-video: #4f80ff;
            --block-audio: #34c759;
            --block-text: #ff9f0a;
            --block-effect: #a020f0;
        }
        * { box-sizing: border-box; user-select: none; }
        body {
            margin: 0;
            font-family: 'Inter', sans-serif;
            background-color: var(--bg-dark);
            color: var(--text-main);
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        header {
            height: 50px;
            background: var(--bg-panel);
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 20px;
        }
        .brand { font-weight: 800; font-size: 18px; }
        .brand span { color: var(--accent); }
        .btn-export {
            background: var(--accent);
            color: #000;
            font-weight: 600;
            border: none;
            padding: 6px 16px;
            border-radius: 4px;
            cursor: pointer;
        }
        .workspace {
            display: flex;
            flex: 1;
            height: calc(100vh - 300px);
        }
        .left-panel, .right-panel {
            width: 280px;
            background: var(--bg-panel);
            display: flex;
            flex-direction: column;
        }
        .left-panel { border-right: 1px solid var(--border); }
        .right-panel { border-left: 1px solid var(--border); }
        .tabs { display: flex; border-bottom: 1px solid var(--border); }
        .tab {
            flex: 1;
            padding: 10px;
            text-align: center;
            cursor: pointer;
            font-size: 12px;
            color: var(--text-dim);
            border-bottom: 2px solid transparent;
        }
        .tab.active { color: var(--text-main); border-bottom-color: var(--accent); }
        .panel-content { flex: 1; overflow-y: auto; padding: 15px; }
        .upload-btn {
            width: 100%;
            padding: 30px;
            border: 2px dashed var(--border);
            border-radius: 8px;
            text-align: center;
            color: var(--text-dim);
            cursor: pointer;
            margin-bottom: 15px;
        }
        .asset-list-item, .effect-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
            background: var(--bg-light);
            padding: 10px;
            margin-bottom: 8px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }
        .center-stage {
            flex: 1;
            background: #000;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        canvas {
            max-width: 90%;
            max-height: 80%;
            background: #000;
            box-shadow: 0 0 30px rgba(0,0,0,0.5);
        }
        .playback-controls {
            margin-top: 15px;
            display: flex;
            gap: 15px;
            align-items: center;
        }
        .icon-btn {
            background: none; border: none; color: white; cursor: pointer; font-size: 20px;
        }
        .prop-group { margin-bottom: 20px; border-bottom: 1px solid var(--border); padding-bottom: 15px; }
        .prop-row {
            display: flex; align-items: center; justify-content: space-between; margin-bottom: 8px; font-size: 13px;
        }
        input[type="range"] { width: 100px; accent-color: var(--accent); }
        input[type="number"] { width: 50px; background: #333; border: 1px solid #444; color: white; border-radius: 4px; padding: 2px 5px;}
        .kf-diamond {
            width: 14px; height: 14px; border: 2px solid var(--text-dim); transform: rotate(45deg);
            cursor: pointer; margin-left: 8px;
        }
        .kf-diamond.active { background: var(--accent); border-color: var(--accent); }
        .timeline-area {
            height: 300px;
            background: var(--bg-panel);
            border-top: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            position: relative;
        }
        .timeline-ruler {
            height: 30px;
            background: var(--timeline-bg);
            border-bottom: 1px solid var(--border);
            position: relative;
            overflow: hidden;
        }
        .tracks-container {
            flex: 1;
            background: var(--timeline-bg);
            position: relative;
            overflow: auto;
            padding: 10px 0;
        }
        .track {
            height: 40px;
            position: relative;
            margin-bottom: 5px;
            border-bottom: 1px solid #222;
        }
        .clip-block {
            position: absolute;
            height: 36px;
            top: 2px;
            border-radius: 4px;
            cursor: pointer;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 11px;
            color: white;
            border: 1px solid rgba(255,255,255,0.1);
        }
        .clip-block.selected { border: 2px solid white; z-index: 10; }
        .clip-video { background: var(--block-video); }
        .clip-image { background: var(--block-video); filter: hue-rotate(20deg); }
        .clip-text { background: var(--block-text); }
        .clip-audio { background: var(--block-audio); height: 25px; top: 7px; }
        .clip-effect { background: var(--block-effect); opacity: 0.8; }
        .handle {
            position: absolute; top: 0; bottom: 0; width: 10px; background: rgba(0,0,0,0.3);
            cursor: ew-resize; z-index: 20; display: none;
        }
        .clip-block:hover .handle, .clip-block.selected .handle { display: block; }
        .handle-left { left: 0; border-right: 1px solid rgba(255,255,255,0.2); }
        .handle-right { right: 0; border-left: 1px solid rgba(255,255,255,0.2); }
        .handle:hover { background: var(--accent); }
        .playhead-container {
            position: absolute; top: 0; bottom: 0; left: 0; right: 0; pointer-events: none; z-index: 100;
        }
        .playhead {
            position: absolute; top: 0; bottom: 0; width: 1px; background: white; z-index: 101;
        }
        #exportOverlay {
            display: none; position: absolute; top:0; left:0; right:0; bottom:0;
            background: rgba(0,0,0,0.9); z-index: 999;
            align-items: center; justify-content: center; flex-direction: column;
        }
        #progressBar {
            width: 300px; height: 4px; background: #333; margin-top: 20px; border-radius: 2px;
        }
        #progressFill {
            width: 0%; height: 100%; background: var(--accent); border-radius: 2px; transition: width 0.1s;
        }
    </style>
</head>
<body>

<header>
    <div class="brand">Web<span>Cut</span></div>
    <div id="timecode">00:00:00</div>
    <button class="btn-export" onclick="startExport()">Export Video</button>
</header>

<div class="workspace">
    <div class="left-panel">
        <div class="tabs">
            <div class="tab active" onclick="switchTab('media')">Media</div>
            <div class="tab" onclick="switchTab('text')">Text</div>
            <div class="tab" onclick="switchTab('effects')">Effects</div>
        </div>

        <div id="panel-media" class="panel-content">
            <div class="upload-btn" onclick="document.getElementById('fileInput').click()">
                + Import Media
            </div>
            <input type="file" id="fileInput" multiple accept="image/*,video/*,audio/*" style="display:none">
            <div id="assetsList"></div>
        </div>

        <div id="panel-text" class="panel-content" style="display:none">
            <div class="upload-btn" onclick="spawnTextLayer()">+ Add Text</div>
        </div>

        <div id="panel-effects" class="panel-content" style="display:none">
            <div class="effect-item" onclick="spawnEffect('blur')"><span>üíß Blur</span><span>+</span></div>
            <div class="effect-item" onclick="spawnEffect('shake')"><span>‚ö° Shake</span><span>+</span></div>
        </div>
    </div>

    <div class="center-stage">
        <canvas id="preview" width="854" height="480"></canvas>
        <div class="playback-controls">
            <button class="icon-btn" onclick="seekToStart()">‚èÆ</button>
            <button class="icon-btn" id="playPauseBtn" onclick="togglePlay()">‚ñ∂</button>
        </div>
    </div>

    <div class="right-panel">
        <div id="noSelection" style="color:var(--text-dim); text-align:center; margin-top:50px;">
            Select a clip to edit
        </div>
        
        <div id="propPanel" style="display:none;">
            <div id="transformGroup" class="prop-group">
                <div style="font-size:12px; color:#888; margin-bottom:10px;">TRANSFORM</div>
                <div class="prop-row">
                    <span>Scale</span>
                    <div style="display:flex; align-items:center;">
                        <input type="number" id="inpScale" step="0.1" onchange="updateProp('scale', this.value)">
                        <div class="kf-diamond" id="kf-scale" onclick="toggleKeyframe('scale')"></div>
                    </div>
                </div>
                <div class="prop-row">
                    <span>Pos X</span>
                    <div style="display:flex; align-items:center;">
                        <input type="number" id="inpX" onchange="updateProp('x', this.value)">
                        <div class="kf-diamond" id="kf-x" onclick="toggleKeyframe('x')"></div>
                    </div>
                </div>
                <div class="prop-row">
                    <span>Pos Y</span>
                    <div style="display:flex; align-items:center;">
                        <input type="number" id="inpY" onchange="updateProp('y', this.value)">
                        <div class="kf-diamond" id="kf-y" onclick="toggleKeyframe('y')"></div>
                    </div>
                </div>
                <div class="prop-row">
                    <span>Opacity</span>
                    <input type="range" id="inpOpacity" max="1" step="0.05" oninput="updateProp('opacity', this.value)">
                </div>
            </div>

            <div id="effectGroup" class="prop-group" style="display:none;">
                <div style="font-size:12px; color:#888; margin-bottom:10px;">EFFECT SETTINGS</div>
                <div class="prop-row">
                    <span>Intensity</span>
                    <input type="range" id="inpIntensity" min="0" max="50" oninput="updateProp('intensity', this.value)">
                </div>
            </div>

            <div id="textProps" style="display:none;" class="prop-group">
                <div style="font-size:12px; color:#888; margin-bottom:10px;">TEXT</div>
                <input type="text" id="inpText" style="width:100%; padding:5px; background:#333; border:1px solid #444; color:white;" oninput="updateProp('text', this.value)">
            </div>
        </div>
    </div>
</div>

<div class="timeline-area">
    <div class="timeline-ruler" id="ruler"></div>
    <div class="tracks-container" id="timelineTracks"></div>
    <div class="playhead-container">
        <div class="playhead" id="playhead" style="left: 20px;"></div>
    </div>
</div>

<div id="exportOverlay">
    <h2 style="color:white;">Exporting...</h2>
    <div id="progressBar"><div id="progressFill"></div></div>
    <p style="color:#aaa; font-size:12px; margin-top:10px;">Please wait</p>
</div>

<script>
const FPS = 30;
const CANVAS_W = 854;
const CANVAS_H = 480;
const PX_PER_SEC = 30;

let state = {
    duration: 60,
    currentTime: 0,
    isPlaying: false,
    isExporting: false,
    layers: [],
    tracks: [1, 2, 3, 4],
    selectedId: null,
    nextId: 1
};

const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
const audioDest = audioCtx.createMediaStreamDestination();
const masterGain = audioCtx.createGain();
masterGain.connect(audioCtx.destination);
masterGain.connect(audioDest);

const canvas = document.getElementById('preview');
const ctx = canvas.getContext('2d');
const ruler = document.getElementById('ruler');
const trackContainer = document.getElementById('timelineTracks');
const fileInput = document.getElementById('fileInput');

function init() {
    renderRuler();
    renderTracks();
    requestAnimationFrame(renderLoop);
    
    ruler.addEventListener('mousedown', (e) => {
        scrub(e);
        const move = (ev) => scrub(ev);
        const up = () => {
            document.removeEventListener('mousemove', move);
            document.removeEventListener('mouseup', up);
        };
        document.addEventListener('mousemove', move);
        document.addEventListener('mouseup', up);
    });

    fileInput.addEventListener('change', handleUpload);
}

function handleUpload(e) {
    const files = Array.from(e.target.files);
    files.forEach(file => {
        const url = URL.createObjectURL(file);
        const type = file.type.startsWith('image') ? 'image' : 
                     file.type.startsWith('video') ? 'video' : 'audio';
        
        const div = document.createElement('div');
        div.className = 'asset-list-item';
        div.innerHTML = `<span>${type === 'video' ? 'üé¨' : type === 'audio' ? 'üéµ' : 'üñºÔ∏è'}</span> <span>${file.name.substring(0,15)}</span>`;
        div.onclick = () => spawnLayer(type, url, file.name);
        document.getElementById('assetsList').appendChild(div);
    });
}

function spawnLayer(type, src, name) {
    let element = null;
    let duration = 5;

    if (type === 'video' || type === 'audio') {
        element = document.createElement(type);
        element.src = src;
        element.crossOrigin = "anonymous";
        element.load();
    } else if (type === 'image') {
        element = new Image();
        element.src = src;
    }

    const layer = {
        id: state.nextId++,
        type: type,
        name: name,
        src: src,
        element: element,
        start: state.currentTime,
        duration: duration,
        trimOffset: 0,
        trackId: type === 'audio' ? 4 : 2,
        props: {
            x: CANVAS_W / 2,
            y: CANVAS_H / 2,
            scale: 1,
            opacity: 1,
            text: type === 'text' ? "Text" : "",
            intensity: 0
        },
        keyframes: { x: [], y: [], scale: [] },
        audioNode: null
    };
    
    if (type === 'video' || type === 'audio') {
        const source = audioCtx.createMediaElementSource(element);
        source.connect(masterGain);
        layer.audioNode = source;
    }

    state.layers.push(layer);
    renderTracks();
    selectLayer(layer.id);
}

function spawnTextLayer() { spawnLayer('text', null, 'Text Layer'); }

function spawnEffect(subType) {
    const layer = {
        id: state.nextId++,
        type: 'effect',
        subType: subType,
        name: subType === 'blur' ? 'Blur' : 'Shake',
        start: state.currentTime,
        duration: 3,
        trimOffset: 0,
        trackId: 1,
        props: { intensity: 10 },
        keyframes: { intensity: [] }
    };
    state.layers.push(layer);
    renderTracks();
    selectLayer(layer.id);
}

function renderRuler() {
    ruler.innerHTML = '';
    for(let i=0; i<state.duration; i++) {
        if(i % 2 === 0) {
            const tick = document.createElement('div');
            tick.style.position = 'absolute';
            tick.style.left = (i * PX_PER_SEC) + 20 + 'px';
            tick.style.color = '#555';
            tick.style.fontSize = '10px';
            tick.style.top = '5px';
            tick.innerText = formatTime(i);
            ruler.appendChild(tick);
        }
    }
}

function renderTracks() {
    trackContainer.innerHTML = '';
    state.tracks.forEach(tId => {
        const trackDiv = document.createElement('div');
        trackDiv.className = 'track';
        
        state.layers.filter(l => l.trackId === tId).forEach(layer => {
            const block = document.createElement('div');
            block.className = `clip-block clip-${layer.type} ${state.selectedId === layer.id ? 'selected' : ''}`;
            block.style.left = (layer.start * PX_PER_SEC) + 20 + 'px';
            block.style.width = (layer.duration * PX_PER_SEC) + 'px';
            block.innerHTML = `<div class="handle handle-left"></div>${layer.name}<div class="handle handle-right"></div>`;
            
            block.onmousedown = (e) => handleBlockInteraction(e, layer, block);
            trackDiv.appendChild(block);
        });
        trackContainer.appendChild(trackDiv);
    });
}

function handleBlockInteraction(e, layer, block) {
    e.stopPropagation();
    selectLayer(layer.id);
    
    const startX = e.clientX;
    const initialStart = layer.start;
    const initialDuration = layer.duration;
    const initialOffset = layer.trimOffset;
    
    const isLeft = e.target.classList.contains('handle-left');
    const isRight = e.target.classList.contains('handle-right');
    const isBody = !isLeft && !isRight;

    const onMove = (mv) => {
        const deltaPx = mv.clientX - startX;
        const deltaSec = deltaPx / PX_PER_SEC;

        if (isBody) {
            layer.start = Math.max(0, initialStart + deltaSec);
        } else if (isRight) {
            layer.duration = Math.max(0.5, initialDuration + deltaSec);
        } else if (isLeft) {
            const newStart = Math.max(0, initialStart + deltaSec);
            const timeDiff = newStart - initialStart;
            if (initialDuration - timeDiff > 0.5) {
                layer.start = newStart;
                layer.duration = initialDuration - timeDiff;
                layer.trimOffset = initialOffset + timeDiff; 
            }
        }
        
        block.style.left = (layer.start * PX_PER_SEC) + 20 + 'px';
        block.style.width = (layer.duration * PX_PER_SEC) + 'px';
    };
    
    const onUp = () => {
        document.removeEventListener('mousemove', onMove);
        document.removeEventListener('mouseup', onUp);
        renderTracks(); 
    };
    document.addEventListener('mousemove', onMove);
    document.addEventListener('mouseup', onUp);
}

function scrub(e) {
    if(state.isExporting) return;
    const rect = ruler.getBoundingClientRect();
    let t = (e.clientX - rect.left - 20) / PX_PER_SEC;
    state.currentTime = Math.max(0, t);
    updatePlayheadUI();
    syncMedia();
}

function syncMedia() {
    state.layers.forEach(l => {
        if(l.type === 'video' || l.type === 'audio') {
            const playTime = (state.currentTime - l.start) + l.trimOffset;
            if(!state.isPlaying && playTime >= 0 && playTime <= (l.duration + l.trimOffset)) {
                l.element.currentTime = playTime;
            }
        }
    });
}

function renderLoop() {
    if (state.isPlaying) {
        state.currentTime += 1/FPS;
        if(state.currentTime >= state.duration) {
            if(state.isExporting) { 
            } else {
                state.isPlaying = false;
                document.getElementById('playPauseBtn').innerText = '‚ñ∂';
            }
        }
        updatePlayheadUI();
    }

    ctx.fillStyle = '#000';
    ctx.fillRect(0,0, CANVAS_W, CANVAS_H);

    const activeLayers = state.layers.filter(l => 
        state.currentTime >= l.start && state.currentTime < (l.start + l.duration)
    ).sort((a,b) => a.trackId - b.trackId);

    let globalBlur = 0;
    let globalShake = 0;

    activeLayers.filter(l => l.type === 'effect').forEach(eff => {
        if(eff.subType === 'blur') globalBlur += eff.props.intensity;
        if(eff.subType === 'shake') globalShake += eff.props.intensity;
    });

    activeLayers.forEach(layer => {
        if(layer.type === 'audio' || layer.type === 'effect') {
            if (layer.type === 'audio') {
                const playTime = (state.currentTime - layer.start) + layer.trimOffset;
                if (state.isPlaying && layer.element.paused) layer.element.play().catch(e=>{});
                else if (!state.isPlaying && !layer.element.paused) layer.element.pause();
                
                if(Math.abs(layer.element.currentTime - playTime) > 0.3) layer.element.currentTime = playTime;
            }
            return; 
        }

        ctx.save();
        if (globalShake > 0) {
             const mx = (Math.random()-0.5) * globalShake;
             const my = (Math.random()-0.5) * globalShake;
             ctx.translate(mx, my);
        }
        if (globalBlur > 0) ctx.filter = `blur(${globalBlur/5}px)`;

        const props = getPropsAtTime(layer, state.currentTime);
        ctx.translate(props.x, props.y);
        ctx.scale(props.scale, props.scale);
        ctx.globalAlpha = props.opacity;

        if (layer.type === 'video') {
            const playTime = (state.currentTime - layer.start) + layer.trimOffset;
            if(state.isPlaying) layer.element.play();
            else layer.element.pause();
            
            if(Math.abs(layer.element.currentTime - playTime) > 0.3) layer.element.currentTime = playTime;
            
            if(layer.element.readyState >= 2) ctx.drawImage(layer.element, -layer.element.videoWidth/2, -layer.element.videoHeight/2);
        } else if (layer.type === 'image') {
             ctx.drawImage(layer.element, -layer.element.width/2, -layer.element.height/2);
        } else if (layer.type === 'text') {
            ctx.font = "bold 50px Arial";
            ctx.fillStyle = "white";
            ctx.textAlign = "center";
            ctx.fillText(props.text, 0, 0);
        }
        ctx.restore();
    });

    if(state.isExporting) {
        const pct = Math.min(100, (state.currentTime / state.duration) * 100);
        document.getElementById('progressFill').style.width = pct + '%';
    }

    requestAnimationFrame(renderLoop);
}

function getPropsAtTime(layer, globalTime) {
    const res = {...layer.props};
    ['x', 'y', 'scale'].forEach(key => {
        const kfs = layer.keyframes[key];
        if(!kfs || kfs.length === 0) return;
        const sorted = [...kfs].sort((a,b) => a.time - b.time);
        if (globalTime <= sorted[0].time) { res[key] = sorted[0].val; return; }
        if (globalTime >= sorted[sorted.length-1].time) { res[key] = sorted[sorted.length-1].val; return; }
        for(let i=0; i<sorted.length-1; i++) {
            if(globalTime >= sorted[i].time && globalTime < sorted[i+1].time) {
                const t = (globalTime - sorted[i].time) / (sorted[i+1].time - sorted[i].time);
                res[key] = sorted[i].val + t * (sorted[i+1].val - sorted[i].val);
                break;
            }
        }
    });
    return res;
}

function updatePlayheadUI() {
    const px = (state.currentTime * PX_PER_SEC) + 20;
    document.getElementById('playhead').style.left = px + 'px';
    document.getElementById('timecode').innerText = formatTime(state.currentTime);
    checkKeyframeActive();
}

function formatTime(s) {
    const mins = Math.floor(s/60);
    const secs = Math.floor(s % 60);
    return `${mins}:${secs.toString().padStart(2,'0')}`;
}

function selectLayer(id) {
    state.selectedId = id;
    renderTracks();
    const layer = state.layers.find(l => l.id === id);
    const panel = document.getElementById('propPanel');
    const noSel = document.getElementById('noSelection');
    
    if(layer) {
        panel.style.display = 'block';
        noSel.style.display = 'none';
        
        const isEffect = layer.type === 'effect';
        const isText = layer.type === 'text';
        
        document.getElementById('transformGroup').style.display = isEffect ? 'none' : 'block';
        document.getElementById('effectGroup').style.display = isEffect ? 'block' : 'none';
        document.getElementById('textProps').style.display = isText ? 'block' : 'none';

        if(isEffect) {
            document.getElementById('inpIntensity').value = layer.props.intensity;
        } else {
            const props = getPropsAtTime(layer, state.currentTime);
            document.getElementById('inpScale').value = props.scale.toFixed(2);
            document.getElementById('inpX').value = Math.round(props.x);
            document.getElementById('inpY').value = Math.round(props.y);
            document.getElementById('inpOpacity').value = props.opacity;
            if(isText) document.getElementById('inpText').value = layer.props.text;
        }
    } else {
        panel.style.display = 'none';
        noSel.style.display = 'block';
    }
}

function switchTab(name) {
    document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
    event.target.classList.add('active');
    document.querySelectorAll('.panel-content').forEach(p => p.style.display = 'none');
    document.getElementById(`panel-${name}`).style.display = 'block';
}

function togglePlay() {
    state.isPlaying = !state.isPlaying;
    document.getElementById('playPauseBtn').innerText = state.isPlaying ? '‚è∏' : '‚ñ∂';
    if(audioCtx.state === 'suspended') audioCtx.resume();
}

function seekToStart() {
    state.currentTime = 0;
    state.isPlaying = false;
    updatePlayheadUI();
    syncMedia();
}

function updateProp(key, val) {
    if(!state.selectedId) return;
    const layer = state.layers.find(l => l.id === state.selectedId);
    if(key === 'text') layer.props.text = val;
    else {
        layer.props[key] = parseFloat(val);
        if(['x','y','scale'].includes(key)) {
            const kf = layer.keyframes[key].find(k => Math.abs(k.time - state.currentTime) < 0.1);
            if(kf) kf.val = parseFloat(val);
        }
    }
}

function toggleKeyframe(prop) {
    if(!state.selectedId) return;
    const layer = state.layers.find(l => l.id === state.selectedId);
    const val = parseFloat(document.getElementById(prop === 'scale' ? 'inpScale' : prop === 'x' ? 'inpX' : 'inpY').value);
    const index = layer.keyframes[prop].findIndex(k => Math.abs(k.time - state.currentTime) < 0.1);
    
    if(index !== -1) layer.keyframes[prop].splice(index, 1);
    else layer.keyframes[prop].push({ time: state.currentTime, val: val });
    checkKeyframeActive();
}

function checkKeyframeActive() {
    if(!state.selectedId) return;
    const layer = state.layers.find(l => l.id === state.selectedId);
    if(!layer.keyframes) return;
    ['x', 'y', 'scale'].forEach(prop => {
        const el = document.getElementById(`kf-${prop}`);
        const has = layer.keyframes[prop].some(k => Math.abs(k.time - state.currentTime) < 0.1);
        if(has) el.classList.add('active'); else el.classList.remove('active');
    });
}

function startExport() {
    const overlay = document.getElementById('exportOverlay');
    overlay.style.display = 'flex';
    state.isPlaying = false;
    state.currentTime = 0;
    state.isExporting = true;
    
    // Mute speakers, keep stream
    masterGain.disconnect(audioCtx.destination);
    
    const stream = canvas.captureStream(FPS);
    const audioTrack = audioDest.stream.getAudioTracks()[0];
    if (audioTrack) stream.addTrack(audioTrack);

    const recorder = new MediaRecorder(stream, { 
        mimeType: 'video/webm;codecs=vp8', 
        videoBitsPerSecond: 2500000 
    });
    
    const chunks = [];
    recorder.ondataavailable = e => { if (e.data.size > 0) chunks.push(e.data); };
    recorder.onstop = () => {
        const blob = new Blob(chunks, { type: 'video/webm' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'webcut_export.webm';
        a.click();
        
        // Restore
        masterGain.connect(audioCtx.destination);
        state.isExporting = false;
        overlay.style.display = 'none';
        alert('Done!');
    };

    recorder.start();
    state.isPlaying = true;
    
    const checker = setInterval(() => {
        if(state.currentTime >= state.duration || !state.isPlaying) {
            recorder.stop();
            state.isPlaying = false;
            clearInterval(checker);
        }
    }, 100);
}

init();
</script>
</body>
</html>